### 介绍
Redis的数据类型包括简单的键值数据类型String，集合类型（List,Set,Hash,Sorted sets)，Bit arrays,HyperLogLogs,Streams,Geo ，每种数据类型都有自己的使用场景，下文就依次说明每种数据类型的典型的应用场景。

### 数据类型

* String
    * 内部存储结构和编码方式  
    String类型内部分为三种编码方式(int,raw,embstr)  
        * 当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。
        * 当你保存的数据中包含字符时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。具体的编码结构如下图:  
        ![String](https://github.com/snailshen2014/redis-learning/blob/master/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/String.jpg?raw=true)  
        
    * 应用场景
        * 分布式锁
        * 计数器
        * K/V存储

* 集合类型（List,Set,Hash,Sorted sets)
    * 聚合统计  
    所谓的聚合统计，就是指统计多个集合元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多个集合的所有元素（并集统计）。
        * 应用场景
            * 在移动应用中，需要统计每天的新增用户数和第二天的留存用户数  
              实现步骤通过设定两个set(A,B)做差集来实现，A叫user-id保存的是所有的登录的用户id,B user-id-20201113日登录的用户id,那么  
              SDIFFSTORE  user-new  user-id-20201113 user-id 运算后计算出来的user:new就是2020年11月13日留存的用户数量（前提是user:id记录了用户的id)  
              注意事项：Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞。所以，我给你分享一个小建议：你可以从主从集群中选择一个  
              从库，让它专门负责聚合计算，或者是把数据读取到客户端，在客户端来完成聚合统计，这样就可以规避阻塞主库实例和其他从库实例的风险了。 （这里有个问题，从库只读不能写，所以做聚合操作可以
              选择在客户端做或业务低峰期在主库做）
     
    * 排序统计  
     我以在电商网站上提供最新评论列表的场景为例，进行讲解。最新评论列表包含了所有评论中的最新留言，这就要求集合类型能对元素保序，也就是说，集合中的元素可以按序排列，这种对元素保序的集合类型叫作有      序集合。在 Redis 常用的 4 个集合类型中（List、Hash、Set、Sorted Set），List 和 Sorted Set 就属于有序集合。List 是按照元素进入 List 的顺序进行排序的，而 Sorted Set 可以根据元素      的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。
        * 应用场景  
            * 商品评论，博客评论  
            通过list的lrange,或者通过Sorted sets的ZRANGEBYSCORE  
            
   
     * 队列、对象映射存储  
       List利用头尾插入，头尾出队可以实现先进先出的简单队列，但这个队列没有队列中间件的一些特性（RocketMQ)，可以用作简单的队列使用。读者可自己了解和传统队列的区别，再次不在详述。    
       Hash，可以利用key field value来映射类的实例的属性和值。
     

* Bit arrays
     * 二值状态统计  
     现在，我们再来分析下第三个场景：二值状态统计。这里的二值状态就是指集合元素的取值就只有 0 和 1 两种。在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态，在      签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。这个时候，我      们就可以选择 Bitmap。这是 Redis 提供的扩展数据类型。我来给你解释一下它的实现原理。Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。String 类型是会保存为二进      制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计      二值状态的数据类型。String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态。你可以把 Bitmap 看作是一个 bit 数组。Bitmap 提供      了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写。不过，需要注意的是，Bitmap 的偏移量是从 0 开始算的，也就是说 offset 的最小值是 0。当使用 SETBIT      对一个 bit 位进行写操作时，这个 bit 位会被设置为 1。Bitmap 还提供了 BITCOUNT 操作，用来统计这个 bit 数组中所有“1”的个数。  
     
         * 应用场景  
             * 签到统计  
               SETBIT uid:sign:3000:202008 2 1   //模拟用户8月3号签到  
               GETBIT uid:sign:3000:202008 2     //判断用户8月3号是否签到  
               BITCOUNT uid:sign:3000:202008     //统计用户8月份签到次数  
             * 连续N天签到统计  
               Bitmap 支持用 BITOP 命令对多个 Bitmap 按位做“与”“或”“异或”的操作，操作的结果会保存到一个新的 Bitmap 中。我以按位“与”操作为例来具体解释一下。可以看到，三个                              Bitmap bm1、bm2 和 bm3，对应 bit 位做“与”操作，结果保存到了一个新的 Bitmap 中,在统计 1 亿个用户连续 10 天的签到情况时，你可以把每天的日期作为 key，每个 key 对应一个 1                  亿位的 Bitmap，每一个 bit 对应一个用户当天的签到情况。接下来，我们对 10 个 Bitmap 做“与”操作，得到的结果也是一个 Bitmap。在这个 Bitmap 中，只有 10 天都签到的用户对应的                  bit 位上的值才会是 1。最后，我们可以用 BITCOUNT 统计下 Bitmap 中的 1 的个数，这就是连续签到 10 天的用户总数了。现在，我们可以计算一下记录了 10 天签到情况后的内存开销。每天                使用 1 个 1 亿位的 Bitmap，大约占 12MB 的内存（10^8/8/1024/1024），10 天的 Bitmap 的内存开销约为 120MB，内存压力不算太大。不过，在实际应用时，最好对 Bitmap 设置过期时                间，让 Redis 自动删除不再需要的签到记录，以节省内存开销。所以，如果只需要统计数据的二值状态，例如商品有没有、用户在不在等，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0                或 1。在记录海量数据时，Bitmap 能够有效地节省内存空间。   
     
* HyperLogLogs  
     * 基数统计  
     基数统计。基数统计就是指统计一个集合中不重复的元素个数。  
         * 应用场景  
             * 网页 UV 的统计  
               网页 UV 的统计有个独特的地方，就是需要去重，一个用户一天内的多次访问只能算作一次。在 Redis 的集合类型中，Set 类型默认支持去重，所以看到有去重需求时，我们可能第一时间就会想到用                Set 类型,通过set可以实现小数据量的统计，但是当数据量很大时，几千万上亿时，这个时候占用的内存量巨大，这个时候就会想到HyperLogLogs了，HyperLogLog 是一种用于统计基数的数据集合                类型，它的最大优势就在于，当集合元素数量非常多时，它计算基数所需的空间总是固定的，而且还很小。在 Redis 中，每个 HyperLogLog 只需要花费 12 KB 内存，就可以计算接近 2^64 个元                素的基数。你看，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面                的每个用户都添加到 HyperLogLog 中。  
               PFADD page1:uv user1 user2 user3 user4 user5  
               接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。  
               PFCOUNT page1:uv  
               不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。这也就意味着，你使用 HyperLogLog 统计的 UV 是                  100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。
               
     
    
* Streams  
    * 队列

* Geo
    * 位置服务  
    以叫车应用的车辆匹配场景为例，介绍下具体如何使用这两个命令。假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是             cars:locations。执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：  
     ```
     GEOADD cars:locations 116.034579 39.030452 33  
     
     ```  
     当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为      中心的 5 公里内的车辆信息，并返回给 LBS 应用。当然， 你可以修改“5”这个参数，来返回更大或更小范围内的车辆信息。  
     
     ```
      GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10
      ```  
      
     另外，我们还可以进一步限定返回的车辆信息。比如，我们可以使用 ASC 选项，让返回的车辆信息按照距离这个中心位置从近到远的方式来排序，以方便选择最近的车辆；还可以使用 COUNT 选项，指定返回的车辆信息的数量。毕竟，5 公里范围内的车辆可能有很多，如果返回全部信息，会占用比较多的数据带宽，这个选项可以帮助控制返回的数据量，节省带宽。可以看到，使用 GEO 数据类型可以非常轻松地操作经纬度这种信息。
    
    
### 数据类型特点对比  

 ![types](https://github.com/snailshen2014/redis-learning/blob/master/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/datatype.jpg?raw=true) 

 

